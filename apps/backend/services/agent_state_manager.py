"""
Agent State Management System for Multi-Agent Orchestration.

Provides comprehensive state tracking, persistence, and synchronization
for 100+ agents with real-time monitoring and historical analysis.
"""

import asyncio
import json
import pickle
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Set, Union, Callable
from enum import Enum
from dataclasses import dataclass, field, asdict
from collections import defaultdict, deque
import uuid
import structlog
from contextlib import asynccontextmanager

from pydantic import BaseModel, Field
from core.config import get_settings
from core.database import get_neo4j
from services.agent_orchestrator import AgentType, TaskStatus

logger = structlog.get_logger(__name__)
settings = get_settings()


class AgentState(str, Enum):
    """Possible states for agents."""
    INITIALIZING = "initializing"    # Agent is being initialized
    IDLE = "idle"                   # Agent is available for tasks
    BUSY = "busy"                   # Agent is executing a task
    BLOCKED = "blocked"             # Agent is waiting for dependencies
    ERROR = "error"                 # Agent encountered an error
    MAINTENANCE = "maintenance"     # Agent is under maintenance
    SHUTDOWN = "shutdown"           # Agent is shutting down
    OFFLINE = "offline"             # Agent is not available


class StateTransition(str, Enum):
    """Valid state transitions."""
    INITIALIZE = "initialize"
    ACTIVATE = "activate"
    ASSIGN_TASK = "assign_task"
    COMPLETE_TASK = "complete_task"
    BLOCK = "block"
    UNBLOCK = "unblock"
    ERROR_OCCURRED = "error_occurred"
    RECOVER = "recover"
    MAINTENANCE_START = "maintenance_start"
    MAINTENANCE_END = "maintenance_end"
    SHUTDOWN = "shutdown"
    OFFLINE = "offline"


class EventType(str, Enum):
    """Types of events in agent lifecycle."""
    STATE_CHANGE = "state_change"
    TASK_ASSIGNED = "task_assigned"
    TASK_STARTED = "task_started"
    TASK_COMPLETED = "task_completed"
    TASK_FAILED = "task_failed"
    ERROR_OCCURRED = "error_occurred"
    PERFORMANCE_METRIC = "performance_metric"
    RESOURCE_USAGE = "resource_usage"
    COMMUNICATION = "communication"
    HEALTH_CHECK = "health_check"


@dataclass
class AgentEvent:
    """Represents an event in agent lifecycle."""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    agent_id: str = field(default=\"\")\n    agent_type: AgentType = field(default=AgentType.TASK_EXECUTOR)\n    event_type: EventType = field(default=EventType.STATE_CHANGE)\n    timestamp: datetime = field(default_factory=datetime.utcnow)\n    data: Dict[str, Any] = field(default_factory=dict)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    correlation_id: Optional[str] = field(default=None)\n    source: str = field(default=\"system\")\n    severity: str = field(default=\"info\")  # debug, info, warning, error, critical\n    tags: List[str] = field(default_factory=list)\n\n\n@dataclass\nclass AgentPerformanceMetrics:\n    \"\"\"Performance metrics for an agent.\"\"\"\n    agent_id: str\n    agent_type: AgentType\n    \n    # Task execution metrics\n    tasks_completed: int = 0\n    tasks_failed: int = 0\n    average_execution_time: float = 0.0\n    min_execution_time: float = float('inf')\n    max_execution_time: float = 0.0\n    \n    # Resource utilization\n    cpu_utilization: float = 0.0\n    memory_utilization: float = 0.0\n    token_utilization: float = 0.0\n    \n    # Availability metrics\n    uptime_percentage: float = 100.0\n    last_active: datetime = field(default_factory=datetime.utcnow)\n    error_count: int = 0\n    recovery_count: int = 0\n    \n    # Quality metrics\n    success_rate: float = 100.0\n    quality_score: float = 0.0\n    user_satisfaction: float = 0.0\n    \n    # Time-based metrics\n    created_at: datetime = field(default_factory=datetime.utcnow)\n    updated_at: datetime = field(default_factory=datetime.utcnow)\n\n\n@dataclass\nclass AgentStateInfo:\n    \"\"\"Complete state information for an agent.\"\"\"\n    agent_id: str\n    agent_type: AgentType\n    current_state: AgentState\n    \n    # State history\n    previous_state: Optional[AgentState] = None\n    state_changed_at: datetime = field(default_factory=datetime.utcnow)\n    state_duration: timedelta = field(default=timedelta())\n    \n    # Current task information\n    current_task_id: Optional[str] = None\n    task_started_at: Optional[datetime] = None\n    task_progress: float = 0.0\n    \n    # Dependencies and blockers\n    blocked_by: Set[str] = field(default_factory=set)\n    blocking: Set[str] = field(default_factory=set)\n    dependencies: Set[str] = field(default_factory=set)\n    \n    # Resource allocation\n    allocated_resources: Dict[str, Any] = field(default_factory=dict)\n    resource_limits: Dict[str, Any] = field(default_factory=dict)\n    \n    # Communication\n    last_heartbeat: datetime = field(default_factory=datetime.utcnow)\n    communication_endpoints: List[str] = field(default_factory=list)\n    \n    # Performance and health\n    health_score: float = 100.0\n    error_count: int = 0\n    last_error: Optional[str] = None\n    last_error_at: Optional[datetime] = None\n    \n    # Metadata\n    created_at: datetime = field(default_factory=datetime.utcnow)\n    updated_at: datetime = field(default_factory=datetime.utcnow)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    tags: Set[str] = field(default_factory=set)\n\n\nclass AgentStateManager:\n    \"\"\"Comprehensive agent state management system.\"\"\"\n    \n    def __init__(self):\n        # State storage\n        self.agent_states: Dict[str, AgentStateInfo] = {}\n        self.agent_events: deque = deque(maxlen=10000)  # Keep last 10K events\n        self.performance_metrics: Dict[str, AgentPerformanceMetrics] = {}\n        \n        # State transition rules\n        self.transition_rules = self._initialize_transition_rules()\n        \n        # Event handlers\n        self.event_handlers: Dict[EventType, List[Callable]] = defaultdict(list)\n        \n        # Background tasks\n        self.cleanup_task: Optional[asyncio.Task] = None\n        self.persistence_task: Optional[asyncio.Task] = None\n        self.monitoring_task: Optional[asyncio.Task] = None\n        \n        # Configuration\n        self.persistence_interval = 60  # seconds\n        self.cleanup_interval = 300     # seconds\n        self.monitoring_interval = 30   # seconds\n        self.event_retention_days = 7\n        \n        # Database connection\n        self.neo4j = None\n        \n        self.is_running = False\n        self.shutdown_event = asyncio.Event()\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize the agent state manager.\"\"\"\n        try:\n            # Initialize database connection\n            self.neo4j = await get_neo4j()\n            \n            # Load existing state from database\n            await self._load_state_from_database()\n            \n            # Start background tasks\n            self.cleanup_task = asyncio.create_task(self._cleanup_loop())\n            self.persistence_task = asyncio.create_task(self._persistence_loop())\n            self.monitoring_task = asyncio.create_task(self._monitoring_loop())\n            \n            self.is_running = True\n            logger.info(\"Agent state manager initialized\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize agent state manager: {str(e)}\")\n            raise\n    \n    def _initialize_transition_rules(self) -> Dict[AgentState, Set[AgentState]]:\n        \"\"\"Initialize valid state transitions.\"\"\"\n        return {\n            AgentState.INITIALIZING: {AgentState.IDLE, AgentState.ERROR, AgentState.OFFLINE},\n            AgentState.IDLE: {AgentState.BUSY, AgentState.BLOCKED, AgentState.MAINTENANCE, \n                             AgentState.SHUTDOWN, AgentState.ERROR, AgentState.OFFLINE},\n            AgentState.BUSY: {AgentState.IDLE, AgentState.BLOCKED, AgentState.ERROR, \n                             AgentState.SHUTDOWN, AgentState.OFFLINE},\n            AgentState.BLOCKED: {AgentState.IDLE, AgentState.BUSY, AgentState.ERROR, \n                               AgentState.SHUTDOWN, AgentState.OFFLINE},\n            AgentState.ERROR: {AgentState.IDLE, AgentState.MAINTENANCE, AgentState.SHUTDOWN, \n                              AgentState.OFFLINE},\n            AgentState.MAINTENANCE: {AgentState.IDLE, AgentState.SHUTDOWN, AgentState.OFFLINE},\n            AgentState.SHUTDOWN: {AgentState.OFFLINE},\n            AgentState.OFFLINE: {AgentState.INITIALIZING}\n        }\n    \n    async def register_agent(\n        self,\n        agent_id: str,\n        agent_type: AgentType,\n        initial_state: AgentState = AgentState.INITIALIZING,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> AgentStateInfo:\n        \"\"\"Register a new agent in the state manager.\"\"\"\n        if agent_id in self.agent_states:\n            logger.warning(f\"Agent {agent_id} already registered, updating...\")\n        \n        state_info = AgentStateInfo(\n            agent_id=agent_id,\n            agent_type=agent_type,\n            current_state=initial_state,\n            metadata=metadata or {}\n        )\n        \n        self.agent_states[agent_id] = state_info\n        \n        # Initialize performance metrics\n        self.performance_metrics[agent_id] = AgentPerformanceMetrics(\n            agent_id=agent_id,\n            agent_type=agent_type\n        )\n        \n        # Create registration event\n        await self._create_event(\n            agent_id=agent_id,\n            agent_type=agent_type,\n            event_type=EventType.STATE_CHANGE,\n            data={\n                \"new_state\": initial_state.value,\n                \"previous_state\": None,\n                \"action\": \"register\"\n            }\n        )\n        \n        logger.info(\n            \"Agent registered\",\n            agent_id=agent_id,\n            agent_type=agent_type.value,\n            initial_state=initial_state.value\n        )\n        \n        return state_info\n    \n    async def transition_state(\n        self,\n        agent_id: str,\n        new_state: AgentState,\n        transition_data: Optional[Dict[str, Any]] = None,\n        validate: bool = True\n    ) -> bool:\n        \"\"\"Transition agent to a new state.\"\"\"\n        if agent_id not in self.agent_states:\n            raise ValueError(f\"Agent {agent_id} not registered\")\n        \n        state_info = self.agent_states[agent_id]\n        current_state = state_info.current_state\n        \n        # Validate transition if requested\n        if validate and not self._is_valid_transition(current_state, new_state):\n            logger.warning(\n                \"Invalid state transition attempted\",\n                agent_id=agent_id,\n                current_state=current_state.value,\n                new_state=new_state.value\n            )\n            return False\n        \n        # Calculate state duration\n        now = datetime.utcnow()\n        state_duration = now - state_info.state_changed_at\n        \n        # Update state info\n        state_info.previous_state = current_state\n        state_info.current_state = new_state\n        state_info.state_changed_at = now\n        state_info.state_duration = state_duration\n        state_info.updated_at = now\n        \n        # Handle state-specific logic\n        await self._handle_state_change(state_info, transition_data)\n        \n        # Create state change event\n        await self._create_event(\n            agent_id=agent_id,\n            agent_type=state_info.agent_type,\n            event_type=EventType.STATE_CHANGE,\n            data={\n                \"new_state\": new_state.value,\n                \"previous_state\": current_state.value,\n                \"duration_seconds\": state_duration.total_seconds(),\n                \"transition_data\": transition_data or {}\n            }\n        )\n        \n        logger.info(\n            \"Agent state transitioned\",\n            agent_id=agent_id,\n            previous_state=current_state.value,\n            new_state=new_state.value,\n            duration_seconds=state_duration.total_seconds()\n        )\n        \n        return True\n    \n    def _is_valid_transition(self, current_state: AgentState, new_state: AgentState) -> bool:\n        \"\"\"Check if a state transition is valid.\"\"\"\n        return new_state in self.transition_rules.get(current_state, set())\n    \n    async def _handle_state_change(\n        self,\n        state_info: AgentStateInfo,\n        transition_data: Optional[Dict[str, Any]] = None\n    ) -> None:\n        \"\"\"Handle state-specific logic during transitions.\"\"\"\n        new_state = state_info.current_state\n        data = transition_data or {}\n        \n        if new_state == AgentState.BUSY:\n            # Agent started working on a task\n            task_id = data.get(\"task_id\")\n            if task_id:\n                state_info.current_task_id = task_id\n                state_info.task_started_at = datetime.utcnow()\n                state_info.task_progress = 0.0\n        \n        elif new_state == AgentState.IDLE:\n            # Agent finished work or became available\n            if state_info.current_task_id:\n                # Task completed\n                task_completion_time = datetime.utcnow() - (state_info.task_started_at or datetime.utcnow())\n                await self._update_performance_metrics(\n                    state_info.agent_id,\n                    task_completion_time.total_seconds(),\n                    success=data.get(\"success\", True)\n                )\n                \n                state_info.current_task_id = None\n                state_info.task_started_at = None\n                state_info.task_progress = 0.0\n        \n        elif new_state == AgentState.ERROR:\n            # Agent encountered an error\n            error_message = data.get(\"error\", \"Unknown error\")\n            state_info.error_count += 1\n            state_info.last_error = error_message\n            state_info.last_error_at = datetime.utcnow()\n            state_info.health_score = max(0, state_info.health_score - 10)\n        \n        elif new_state == AgentState.BLOCKED:\n            # Agent is blocked by dependencies\n            blockers = data.get(\"blocked_by\", [])\n            state_info.blocked_by = set(blockers)\n        \n        # Update heartbeat\n        state_info.last_heartbeat = datetime.utcnow()\n    \n    async def _update_performance_metrics(\n        self,\n        agent_id: str,\n        execution_time: float,\n        success: bool = True\n    ) -> None:\n        \"\"\"Update performance metrics for an agent.\"\"\"\n        if agent_id not in self.performance_metrics:\n            return\n        \n        metrics = self.performance_metrics[agent_id]\n        \n        if success:\n            metrics.tasks_completed += 1\n            \n            # Update execution time statistics\n            if metrics.tasks_completed == 1:\n                metrics.average_execution_time = execution_time\n            else:\n                total_tasks = metrics.tasks_completed + metrics.tasks_failed\n                metrics.average_execution_time = (\n                    (metrics.average_execution_time * (total_tasks - 1) + execution_time) / total_tasks\n                )\n            \n            metrics.min_execution_time = min(metrics.min_execution_time, execution_time)\n            metrics.max_execution_time = max(metrics.max_execution_time, execution_time)\n        else:\n            metrics.tasks_failed += 1\n        \n        # Update success rate\n        total_tasks = metrics.tasks_completed + metrics.tasks_failed\n        metrics.success_rate = (metrics.tasks_completed / total_tasks) * 100 if total_tasks > 0 else 0\n        \n        metrics.last_active = datetime.utcnow()\n        metrics.updated_at = datetime.utcnow()\n    \n    async def assign_task(\n        self,\n        agent_id: str,\n        task_id: str,\n        task_data: Optional[Dict[str, Any]] = None\n    ) -> bool:\n        \"\"\"Assign a task to an agent.\"\"\"\n        if agent_id not in self.agent_states:\n            return False\n        \n        state_info = self.agent_states[agent_id]\n        \n        # Check if agent is available\n        if state_info.current_state != AgentState.IDLE:\n            logger.warning(\n                \"Cannot assign task to agent in state\",\n                agent_id=agent_id,\n                current_state=state_info.current_state.value,\n                task_id=task_id\n            )\n            return False\n        \n        # Transition to busy state\n        success = await self.transition_state(\n            agent_id,\n            AgentState.BUSY,\n            {\"task_id\": task_id, **(task_data or {})}\n        )\n        \n        if success:\n            # Create task assignment event\n            await self._create_event(\n                agent_id=agent_id,\n                agent_type=state_info.agent_type,\n                event_type=EventType.TASK_ASSIGNED,\n                data={\n                    \"task_id\": task_id,\n                    \"task_data\": task_data or {}\n                },\n                correlation_id=task_id\n            )\n        \n        return success\n    \n    async def complete_task(\n        self,\n        agent_id: str,\n        task_id: str,\n        result: Optional[Dict[str, Any]] = None,\n        success: bool = True\n    ) -> bool:\n        \"\"\"Mark a task as completed for an agent.\"\"\"\n        if agent_id not in self.agent_states:\n            return False\n        \n        state_info = self.agent_states[agent_id]\n        \n        # Verify agent is working on this task\n        if state_info.current_task_id != task_id:\n            logger.warning(\n                \"Task completion mismatch\",\n                agent_id=agent_id,\n                expected_task=state_info.current_task_id,\n                completed_task=task_id\n            )\n            return False\n        \n        # Transition to idle state\n        transition_success = await self.transition_state(\n            agent_id,\n            AgentState.IDLE,\n            {\"task_id\": task_id, \"success\": success, \"result\": result}\n        )\n        \n        if transition_success:\n            # Create task completion event\n            event_type = EventType.TASK_COMPLETED if success else EventType.TASK_FAILED\n            await self._create_event(\n                agent_id=agent_id,\n                agent_type=state_info.agent_type,\n                event_type=event_type,\n                data={\n                    \"task_id\": task_id,\n                    \"success\": success,\n                    \"result\": result or {}\n                },\n                correlation_id=task_id\n            )\n        \n        return transition_success\n    \n    async def update_task_progress(\n        self,\n        agent_id: str,\n        progress: float,\n        status_message: Optional[str] = None\n    ) -> bool:\n        \"\"\"Update task progress for an agent.\"\"\"\n        if agent_id not in self.agent_states:\n            return False\n        \n        state_info = self.agent_states[agent_id]\n        \n        if state_info.current_state != AgentState.BUSY or not state_info.current_task_id:\n            return False\n        \n        state_info.task_progress = max(0.0, min(1.0, progress))\n        state_info.updated_at = datetime.utcnow()\n        \n        # Create progress event (only for significant progress updates)\n        if progress == 0.0 or progress >= 1.0 or int(progress * 10) != int(state_info.task_progress * 10):\n            await self._create_event(\n                agent_id=agent_id,\n                agent_type=state_info.agent_type,\n                event_type=EventType.PERFORMANCE_METRIC,\n                data={\n                    \"task_id\": state_info.current_task_id,\n                    \"progress\": progress,\n                    \"status_message\": status_message\n                },\n                correlation_id=state_info.current_task_id\n            )\n        \n        return True\n    \n    async def _create_event(\n        self,\n        agent_id: str,\n        agent_type: AgentType,\n        event_type: EventType,\n        data: Dict[str, Any],\n        correlation_id: Optional[str] = None,\n        severity: str = \"info\",\n        tags: Optional[List[str]] = None\n    ) -> AgentEvent:\n        \"\"\"Create and store an agent event.\"\"\"\n        event = AgentEvent(\n            agent_id=agent_id,\n            agent_type=agent_type,\n            event_type=event_type,\n            data=data,\n            correlation_id=correlation_id,\n            severity=severity,\n            tags=tags or []\n        )\n        \n        self.agent_events.append(event)\n        \n        # Trigger event handlers\n        handlers = self.event_handlers.get(event_type, [])\n        for handler in handlers:\n            try:\n                await handler(event)\n            except Exception as e:\n                logger.error(f\"Event handler failed: {str(e)}\", exc_info=True)\n        \n        return event\n    \n    def register_event_handler(\n        self,\n        event_type: EventType,\n        handler: Callable[[AgentEvent], None]\n    ) -> None:\n        \"\"\"Register an event handler for specific event types.\"\"\"\n        self.event_handlers[event_type].append(handler)\n    \n    def get_agent_state(self, agent_id: str) -> Optional[AgentStateInfo]:\n        \"\"\"Get current state of an agent.\"\"\"\n        return self.agent_states.get(agent_id)\n    \n    def get_agents_by_state(self, state: AgentState) -> List[AgentStateInfo]:\n        \"\"\"Get all agents in a specific state.\"\"\"\n        return [\n            state_info for state_info in self.agent_states.values()\n            if state_info.current_state == state\n        ]\n    \n    def get_agents_by_type(self, agent_type: AgentType) -> List[AgentStateInfo]:\n        \"\"\"Get all agents of a specific type.\"\"\"\n        return [\n            state_info for state_info in self.agent_states.values()\n            if state_info.agent_type == agent_type\n        ]\n    \n    def get_available_agents(self, agent_type: Optional[AgentType] = None) -> List[AgentStateInfo]:\n        \"\"\"Get all available (idle) agents, optionally filtered by type.\"\"\"\n        available = self.get_agents_by_state(AgentState.IDLE)\n        \n        if agent_type:\n            available = [agent for agent in available if agent.agent_type == agent_type]\n        \n        return available\n    \n    def get_performance_metrics(self, agent_id: str) -> Optional[AgentPerformanceMetrics]:\n        \"\"\"Get performance metrics for an agent.\"\"\"\n        return self.performance_metrics.get(agent_id)\n    \n    def get_recent_events(\n        self,\n        agent_id: Optional[str] = None,\n        event_type: Optional[EventType] = None,\n        limit: int = 100,\n        since: Optional[datetime] = None\n    ) -> List[AgentEvent]:\n        \"\"\"Get recent events with optional filtering.\"\"\"\n        events = list(self.agent_events)\n        \n        # Apply filters\n        if agent_id:\n            events = [e for e in events if e.agent_id == agent_id]\n        \n        if event_type:\n            events = [e for e in events if e.event_type == event_type]\n        \n        if since:\n            events = [e for e in events if e.timestamp >= since]\n        \n        # Sort by timestamp (newest first) and limit\n        events.sort(key=lambda e: e.timestamp, reverse=True)\n        return events[:limit]\n    \n    async def get_system_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system status.\"\"\"\n        # Agent state distribution\n        state_distribution = defaultdict(int)\n        type_distribution = defaultdict(int)\n        \n        for state_info in self.agent_states.values():\n            state_distribution[state_info.current_state.value] += 1\n            type_distribution[state_info.agent_type.value] += 1\n        \n        # Performance summary\n        total_tasks = sum(metrics.tasks_completed + metrics.tasks_failed \n                         for metrics in self.performance_metrics.values())\n        total_completed = sum(metrics.tasks_completed for metrics in self.performance_metrics.values())\n        \n        overall_success_rate = (total_completed / total_tasks * 100) if total_tasks > 0 else 0\n        \n        return {\n            \"total_agents\": len(self.agent_states),\n            \"state_distribution\": dict(state_distribution),\n            \"type_distribution\": dict(type_distribution),\n            \"total_events\": len(self.agent_events),\n            \"performance_summary\": {\n                \"total_tasks\": total_tasks,\n                \"total_completed\": total_completed,\n                \"overall_success_rate\": overall_success_rate\n            },\n            \"system_health\": \"healthy\" if self.is_running else \"degraded\",\n            \"uptime_seconds\": (datetime.utcnow() - self._start_time).total_seconds() if hasattr(self, '_start_time') else 0\n        }\n    \n    async def _load_state_from_database(self) -> None:\n        \"\"\"Load agent states from Neo4j database.\"\"\"\n        # This would load persisted state from the database\n        # For now, we'll start with empty state\n        logger.info(\"State loaded from database (placeholder implementation)\")\n    \n    async def _cleanup_loop(self) -> None:\n        \"\"\"Background task for cleaning up old events and metrics.\"\"\"\n        while not self.shutdown_event.is_set():\n            try:\n                await self._cleanup_old_events()\n                await asyncio.sleep(self.cleanup_interval)\n            except Exception as e:\n                logger.error(f\"Error in cleanup loop: {str(e)}\", exc_info=True)\n                await asyncio.sleep(30)\n    \n    async def _persistence_loop(self) -> None:\n        \"\"\"Background task for persisting state to database.\"\"\"\n        while not self.shutdown_event.is_set():\n            try:\n                await self._persist_state_to_database()\n                await asyncio.sleep(self.persistence_interval)\n            except Exception as e:\n                logger.error(f\"Error in persistence loop: {str(e)}\", exc_info=True)\n                await asyncio.sleep(30)\n    \n    async def _monitoring_loop(self) -> None:\n        \"\"\"Background task for monitoring agent health.\"\"\"\n        while not self.shutdown_event.is_set():\n            try:\n                await self._check_agent_health()\n                await asyncio.sleep(self.monitoring_interval)\n            except Exception as e:\n                logger.error(f\"Error in monitoring loop: {str(e)}\", exc_info=True)\n                await asyncio.sleep(30)\n    \n    async def shutdown(self) -> None:\n        \"\"\"Gracefully shutdown the state manager.\"\"\"\n        logger.info(\"Shutting down agent state manager\")\n        \n        self.shutdown_event.set()\n        \n        # Cancel background tasks\n        for task in [self.cleanup_task, self.persistence_task, self.monitoring_task]:\n            if task:\n                task.cancel()\n        \n        # Final state persistence\n        await self._persist_state_to_database()\n        \n        self.is_running = False\n        logger.info(\"Agent state manager shutdown complete\")\n\n\n# Global agent state manager instance\nagent_state_manager = AgentStateManager()\n\n\nasync def get_agent_state_manager() -> AgentStateManager:\n    \"\"\"Get the global agent state manager instance.\"\"\"\n    if not agent_state_manager.is_running:\n        await agent_state_manager.initialize()\n    return agent_state_manager