"""
Agent Communication Protocols for Multi-Agent Orchestration.

Implements secure, efficient communication protocols for 100+ agents with
message routing, event streaming, and coordination patterns.
"""

import asyncio
import json
import time
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Set, Callable, Union, Tuple
from enum import Enum
from dataclasses import dataclass, field, asdict
from collections import defaultdict, deque
import uuid
import hashlib
import structlog
from contextlib import asynccontextmanager

from pydantic import BaseModel, Field, validator
from core.config import get_settings
from services.agent_orchestrator import AgentType
from services.agent_state_manager import AgentState

logger = structlog.get_logger(__name__)
settings = get_settings()


class MessageType(str, Enum):
    """Types of messages in the communication system."""
    # Task-related messages
    TASK_ASSIGNMENT = "task_assignment"
    TASK_START = "task_start"
    TASK_PROGRESS = "task_progress"
    TASK_COMPLETE = "task_complete"
    TASK_FAILED = "task_failed"
    
    # Coordination messages
    COORDINATION_REQUEST = "coordination_request"
    COORDINATION_RESPONSE = "coordination_response"
    DEPENDENCY_NOTIFICATION = "dependency_notification"
    RESOURCE_REQUEST = "resource_request"
    RESOURCE_RESPONSE = "resource_response"
    
    # Status and health
    HEARTBEAT = "heartbeat"
    STATUS_UPDATE = "status_update"
    HEALTH_CHECK = "health_check"
    ERROR_REPORT = "error_report"
    
    # System messages
    BROADCAST = "broadcast"
    SHUTDOWN = "shutdown"
    CONFIGURATION_UPDATE = "configuration_update"
    
    # Data exchange
    DATA_QUERY = "data_query"
    DATA_RESPONSE = "data_response"
    CONTEXT_UPDATE = "context_update"


class MessagePriority(str, Enum):
    """Message priority levels."""
    CRITICAL = "critical"    # System-critical messages (shutdown, errors)
    HIGH = "high"           # Urgent coordination messages
    NORMAL = "normal"       # Standard task messages
    LOW = "low"             # Background updates, metrics


class DeliveryMode(str, Enum):
    """Message delivery modes."""
    DIRECT = "direct"           # Direct agent-to-agent
    BROADCAST = "broadcast"     # One-to-many broadcast
    MULTICAST = "multicast"     # To specific group of agents
    PUBLISH_SUBSCRIBE = "pub_sub"  # Topic-based messaging


@dataclass
class MessageHeader:
    """Message header with routing and metadata information."""
    message_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    message_type: MessageType = MessageType.STATUS_UPDATE
    priority: MessagePriority = MessagePriority.NORMAL
    delivery_mode: DeliveryMode = DeliveryMode.DIRECT
    
    # Routing information
    sender_id: str = field(default="")
    sender_type: Optional[AgentType] = None
    recipient_id: Optional[str] = None
    recipient_type: Optional[AgentType] = None
    recipients: List[str] = field(default_factory=list)
    topic: Optional[str] = None
    
    # Message metadata
    timestamp: datetime = field(default_factory=datetime.utcnow)
    correlation_id: Optional[str] = None
    conversation_id: Optional[str] = None
    reply_to: Optional[str] = None
    ttl_seconds: int = 300  # Time to live
    
    # Quality of service
    requires_ack: bool = False
    retry_count: int = 0
    max_retries: int = 3
    
    # Security and validation
    checksum: Optional[str] = None
    encryption: bool = False
    signature: Optional[str] = None


@dataclass
class Message:
    """Complete message with header and payload."""
    header: MessageHeader
    payload: Dict[str, Any] = field(default_factory=dict)
    raw_size: int = field(default=0, init=False)
    
    def __post_init__(self):
        # Calculate message size
        self.raw_size = len(json.dumps(asdict(self), default=str))
        
        # Generate checksum if not provided
        if not self.header.checksum:
            self.header.checksum = self._calculate_checksum()
    
    def _calculate_checksum(self) -> str:
        """Calculate message checksum for integrity verification."""
        content = json.dumps(self.payload, sort_keys=True)
        return hashlib.sha256(content.encode()).hexdigest()[:16]
    
    def verify_integrity(self) -> bool:
        """Verify message integrity using checksum."""
        return self.header.checksum == self._calculate_checksum()
    
    def is_expired(self) -> bool:
        """Check if message has expired based on TTL."""
        age = (datetime.utcnow() - self.header.timestamp).total_seconds()
        return age > self.header.ttl_seconds


class MessageRouter:
    """Handles message routing and delivery strategies."""
    
    def __init__(self, communication_system: 'AgentCommunicationSystem'):\n        self.comm_system = communication_system\n        \n        # Routing tables\n        self.agent_routes: Dict[str, Dict[str, Any]] = {}  # agent_id -> routing info\n        self.topic_subscriptions: Dict[str, Set[str]] = defaultdict(set)  # topic -> agent_ids\n        self.type_subscriptions: Dict[AgentType, Set[str]] = defaultdict(set)  # type -> agent_ids\n        \n        # Message queues for different delivery modes\n        self.direct_queues: Dict[str, deque] = defaultdict(deque)  # agent_id -> messages\n        self.broadcast_buffer: deque = deque(maxlen=1000)\n        self.multicast_groups: Dict[str, Set[str]] = {}  # group_name -> agent_ids\n        \n        # Performance metrics\n        self.routing_metrics = {\n            \"messages_routed\": 0,\n            \"delivery_failures\": 0,\n            \"average_routing_time\": 0.0,\n            \"queue_sizes\": {}\n        }\n    \n    async def route_message(self, message: Message) -> List[str]:\n        \"\"\"Route a message to its intended recipients.\"\"\"\n        start_time = time.time()\n        delivered_to = []\n        \n        try:\n            if message.header.delivery_mode == DeliveryMode.DIRECT:\n                delivered_to = await self._route_direct(message)\n            elif message.header.delivery_mode == DeliveryMode.BROADCAST:\n                delivered_to = await self._route_broadcast(message)\n            elif message.header.delivery_mode == DeliveryMode.MULTICAST:\n                delivered_to = await self._route_multicast(message)\n            elif message.header.delivery_mode == DeliveryMode.PUBLISH_SUBSCRIBE:\n                delivered_to = await self._route_pub_sub(message)\n            \n            # Update metrics\n            routing_time = time.time() - start_time\n            self._update_routing_metrics(routing_time, len(delivered_to), success=True)\n            \n            logger.debug(\n                \"Message routed successfully\",\n                message_id=message.header.message_id,\n                delivery_mode=message.header.delivery_mode.value,\n                recipients=len(delivered_to),\n                routing_time_ms=routing_time * 1000\n            )\n            \n        except Exception as e:\n            self._update_routing_metrics(time.time() - start_time, 0, success=False)\n            logger.error(\n                \"Message routing failed\",\n                message_id=message.header.message_id,\n                error=str(e)\n            )\n            raise\n        \n        return delivered_to\n    \n    async def _route_direct(self, message: Message) -> List[str]:\n        \"\"\"Route message directly to specific recipient.\"\"\"\n        recipient_id = message.header.recipient_id\n        if not recipient_id:\n            raise ValueError(\"Direct message requires recipient_id\")\n        \n        if recipient_id in self.agent_routes:\n            self.direct_queues[recipient_id].append(message)\n            return [recipient_id]\n        else:\n            logger.warning(f\"Recipient {recipient_id} not found for direct routing\")\n            return []\n    \n    async def _route_broadcast(self, message: Message) -> List[str]:\n        \"\"\"Route message to all registered agents.\"\"\"\n        delivered_to = []\n        \n        for agent_id in self.agent_routes.keys():\n            # Skip sender\n            if agent_id != message.header.sender_id:\n                self.direct_queues[agent_id].append(message)\n                delivered_to.append(agent_id)\n        \n        self.broadcast_buffer.append(message)\n        return delivered_to\n    \n    async def _route_multicast(self, message: Message) -> List[str]:\n        \"\"\"Route message to specific list of recipients.\"\"\"\n        delivered_to = []\n        recipients = message.header.recipients\n        \n        for recipient_id in recipients:\n            if recipient_id in self.agent_routes:\n                self.direct_queues[recipient_id].append(message)\n                delivered_to.append(recipient_id)\n        \n        return delivered_to\n    \n    async def _route_pub_sub(self, message: Message) -> List[str]:\n        \"\"\"Route message based on topic subscriptions.\"\"\"\n        delivered_to = []\n        topic = message.header.topic\n        \n        if topic and topic in self.topic_subscriptions:\n            subscribers = self.topic_subscriptions[topic]\n            for agent_id in subscribers:\n                if agent_id != message.header.sender_id:\n                    self.direct_queues[agent_id].append(message)\n                    delivered_to.append(agent_id)\n        \n        return delivered_to\n    \n    def register_agent(self, agent_id: str, agent_type: AgentType, routing_info: Dict[str, Any]) -> None:\n        \"\"\"Register an agent for message routing.\"\"\"\n        self.agent_routes[agent_id] = {\n            \"agent_type\": agent_type,\n            \"routing_info\": routing_info,\n            \"registered_at\": datetime.utcnow(),\n            \"last_activity\": datetime.utcnow()\n        }\n        \n        # Add to type subscriptions\n        self.type_subscriptions[agent_type].add(agent_id)\n        \n        logger.info(f\"Agent {agent_id} registered for routing\")\n    \n    def unregister_agent(self, agent_id: str) -> None:\n        \"\"\"Unregister an agent from routing.\"\"\"\n        if agent_id in self.agent_routes:\n            agent_info = self.agent_routes[agent_id]\n            agent_type = agent_info[\"agent_type\"]\n            \n            # Remove from routing tables\n            del self.agent_routes[agent_id]\n            self.type_subscriptions[agent_type].discard(agent_id)\n            \n            # Remove from topic subscriptions\n            for subscribers in self.topic_subscriptions.values():\n                subscribers.discard(agent_id)\n            \n            # Clear message queue\n            if agent_id in self.direct_queues:\n                del self.direct_queues[agent_id]\n            \n            logger.info(f\"Agent {agent_id} unregistered from routing\")\n    \n    def subscribe_to_topic(self, agent_id: str, topic: str) -> None:\n        \"\"\"Subscribe an agent to a topic.\"\"\"\n        self.topic_subscriptions[topic].add(agent_id)\n        logger.debug(f\"Agent {agent_id} subscribed to topic {topic}\")\n    \n    def unsubscribe_from_topic(self, agent_id: str, topic: str) -> None:\n        \"\"\"Unsubscribe an agent from a topic.\"\"\"\n        self.topic_subscriptions[topic].discard(agent_id)\n        logger.debug(f\"Agent {agent_id} unsubscribed from topic {topic}\")\n    \n    def get_pending_messages(self, agent_id: str, max_messages: int = 10) -> List[Message]:\n        \"\"\"Get pending messages for an agent.\"\"\"\n        if agent_id not in self.direct_queues:\n            return []\n        \n        messages = []\n        queue = self.direct_queues[agent_id]\n        \n        for _ in range(min(max_messages, len(queue))):\n            if queue:\n                message = queue.popleft()\n                # Check if message is still valid (not expired)\n                if not message.is_expired():\n                    messages.append(message)\n        \n        return messages\n    \n    def _update_routing_metrics(self, routing_time: float, recipients: int, success: bool) -> None:\n        \"\"\"Update routing performance metrics.\"\"\"\n        self.routing_metrics[\"messages_routed\"] += 1\n        \n        if not success:\n            self.routing_metrics[\"delivery_failures\"] += 1\n        \n        # Update average routing time\n        current_avg = self.routing_metrics[\"average_routing_time\"]\n        message_count = self.routing_metrics[\"messages_routed\"]\n        \n        new_avg = ((current_avg * (message_count - 1)) + routing_time) / message_count\n        self.routing_metrics[\"average_routing_time\"] = new_avg\n        \n        # Update queue sizes\n        self.routing_metrics[\"queue_sizes\"] = {\n            agent_id: len(queue) for agent_id, queue in self.direct_queues.items()\n        }\n\n\nclass EventStream:\n    \"\"\"Event streaming system for real-time agent communication.\"\"\"\n    \n    def __init__(self):\n        self.streams: Dict[str, asyncio.Queue] = {}  # stream_id -> message queue\n        self.subscribers: Dict[str, Set[str]] = defaultdict(set)  # stream_id -> agent_ids\n        self.stream_metadata: Dict[str, Dict[str, Any]] = {}\n        \n        # Performance settings\n        self.max_stream_size = 1000\n        self.default_timeout = 30.0\n    \n    async def create_stream(self, stream_id: str, metadata: Optional[Dict[str, Any]] = None) -> None:\n        \"\"\"Create a new event stream.\"\"\"\n        self.streams[stream_id] = asyncio.Queue(maxsize=self.max_stream_size)\n        self.stream_metadata[stream_id] = metadata or {}\n        self.stream_metadata[stream_id][\"created_at\"] = datetime.utcnow()\n        \n        logger.info(f\"Event stream {stream_id} created\")\n    \n    async def publish_event(self, stream_id: str, event_data: Dict[str, Any]) -> None:\n        \"\"\"Publish an event to a stream.\"\"\"\n        if stream_id not in self.streams:\n            await self.create_stream(stream_id)\n        \n        event = {\n            \"event_id\": str(uuid.uuid4()),\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"data\": event_data\n        }\n        \n        try:\n            await asyncio.wait_for(\n                self.streams[stream_id].put(event),\n                timeout=1.0  # Don't block if stream is full\n            )\n        except asyncio.TimeoutError:\n            logger.warning(f\"Stream {stream_id} is full, dropping event\")\n    \n    async def subscribe_to_stream(self, stream_id: str, agent_id: str) -> None:\n        \"\"\"Subscribe an agent to an event stream.\"\"\"\n        if stream_id not in self.streams:\n            await self.create_stream(stream_id)\n        \n        self.subscribers[stream_id].add(agent_id)\n        logger.debug(f\"Agent {agent_id} subscribed to stream {stream_id}\")\n    \n    async def unsubscribe_from_stream(self, stream_id: str, agent_id: str) -> None:\n        \"\"\"Unsubscribe an agent from an event stream.\"\"\"\n        self.subscribers[stream_id].discard(agent_id)\n        logger.debug(f\"Agent {agent_id} unsubscribed from stream {stream_id}\")\n    \n    async def get_events(self, stream_id: str, timeout: Optional[float] = None) -> List[Dict[str, Any]]:\n        \"\"\"Get events from a stream with optional timeout.\"\"\"\n        if stream_id not in self.streams:\n            return []\n        \n        events = []\n        stream = self.streams[stream_id]\n        timeout = timeout or self.default_timeout\n        \n        try:\n            # Get all available events without blocking\n            while not stream.empty():\n                event = await asyncio.wait_for(stream.get(), timeout=0.1)\n                events.append(event)\n        except asyncio.TimeoutError:\n            pass  # No more events available\n        \n        return events\n\n\nclass AgentCommunicationSystem:\n    \"\"\"Central communication system for multi-agent orchestration.\"\"\"\n    \n    def __init__(self):\n        # Core components\n        self.message_router = MessageRouter(self)\n        self.event_stream = EventStream()\n        \n        # Message handling\n        self.message_handlers: Dict[MessageType, List[Callable]] = defaultdict(list)\n        self.middleware: List[Callable] = []  # Message processing middleware\n        \n        # Connection management\n        self.active_connections: Dict[str, Dict[str, Any]] = {}  # agent_id -> connection_info\n        self.connection_pools: Dict[AgentType, List[str]] = defaultdict(list)\n        \n        # Quality of service\n        self.message_acknowledgments: Dict[str, Dict[str, Any]] = {}  # message_id -> ack_info\n        self.retry_queues: Dict[MessagePriority, deque] = {\n            priority: deque() for priority in MessagePriority\n        }\n        \n        # Security and validation\n        self.trusted_agents: Set[str] = set()\n        self.message_validators: List[Callable] = []\n        \n        # Performance metrics\n        self.metrics = {\n            \"messages_sent\": 0,\n            \"messages_received\": 0,\n            \"messages_dropped\": 0,\n            \"average_latency_ms\": 0.0,\n            \"active_agents\": 0,\n            \"throughput_per_second\": 0.0\n        }\n        \n        # Background tasks\n        self.heartbeat_task: Optional[asyncio.Task] = None\n        self.retry_task: Optional[asyncio.Task] = None\n        self.metrics_task: Optional[asyncio.Task] = None\n        self.cleanup_task: Optional[asyncio.Task] = None\n        \n        self.is_running = False\n        self.shutdown_event = asyncio.Event()\n    \n    async def initialize(self) -> None:\n        \"\"\"Initialize the communication system.\"\"\"\n        try:\n            # Start background tasks\n            self.heartbeat_task = asyncio.create_task(self._heartbeat_loop())\n            self.retry_task = asyncio.create_task(self._retry_loop())\n            self.metrics_task = asyncio.create_task(self._metrics_loop())\n            self.cleanup_task = asyncio.create_task(self._cleanup_loop())\n            \n            # Register default message handlers\n            await self._register_default_handlers()\n            \n            self.is_running = True\n            logger.info(\"Agent communication system initialized\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize communication system: {str(e)}\")\n            raise\n    \n    async def register_agent(\n        self,\n        agent_id: str,\n        agent_type: AgentType,\n        connection_info: Optional[Dict[str, Any]] = None\n    ) -> None:\n        \"\"\"Register an agent for communication.\"\"\"\n        # Register with message router\n        routing_info = connection_info or {\"protocol\": \"internal\"}\n        self.message_router.register_agent(agent_id, agent_type, routing_info)\n        \n        # Store connection information\n        self.active_connections[agent_id] = {\n            \"agent_type\": agent_type,\n            \"connection_info\": routing_info,\n            \"registered_at\": datetime.utcnow(),\n            \"last_heartbeat\": datetime.utcnow(),\n            \"message_count\": 0\n        }\n        \n        # Add to connection pool\n        self.connection_pools[agent_type].append(agent_id)\n        \n        # Add to trusted agents (in production, this would require proper authentication)\n        self.trusted_agents.add(agent_id)\n        \n        # Subscribe to system events\n        await self.event_stream.subscribe_to_stream(\"system_events\", agent_id)\n        \n        logger.info(\n            \"Agent registered for communication\",\n            agent_id=agent_id,\n            agent_type=agent_type.value\n        )\n    \n    async def unregister_agent(self, agent_id: str) -> None:\n        \"\"\"Unregister an agent from communication.\"\"\"\n        if agent_id in self.active_connections:\n            connection_info = self.active_connections[agent_id]\n            agent_type = connection_info[\"agent_type\"]\n            \n            # Unregister from router\n            self.message_router.unregister_agent(agent_id)\n            \n            # Remove from connection tracking\n            del self.active_connections[agent_id]\n            \n            # Remove from connection pool\n            if agent_id in self.connection_pools[agent_type]:\n                self.connection_pools[agent_type].remove(agent_id)\n            \n            # Remove from trusted agents\n            self.trusted_agents.discard(agent_id)\n            \n            logger.info(f\"Agent {agent_id} unregistered from communication\")\n    \n    async def send_message(\n        self,\n        message_type: MessageType,\n        sender_id: str,\n        payload: Dict[str, Any],\n        recipient_id: Optional[str] = None,\n        recipients: Optional[List[str]] = None,\n        topic: Optional[str] = None,\n        priority: MessagePriority = MessagePriority.NORMAL,\n        delivery_mode: DeliveryMode = DeliveryMode.DIRECT,\n        requires_ack: bool = False,\n        correlation_id: Optional[str] = None\n    ) -> str:\n        \"\"\"Send a message through the communication system.\"\"\"\n        \n        # Create message header\n        header = MessageHeader(\n            message_type=message_type,\n            priority=priority,\n            delivery_mode=delivery_mode,\n            sender_id=sender_id,\n            recipient_id=recipient_id,\n            recipients=recipients or [],\n            topic=topic,\n            requires_ack=requires_ack,\n            correlation_id=correlation_id\n        )\n        \n        # Get sender type\n        if sender_id in self.active_connections:\n            header.sender_type = self.active_connections[sender_id][\"agent_type\"]\n        \n        # Create complete message\n        message = Message(header=header, payload=payload)\n        \n        # Validate message\n        if not await self._validate_message(message):\n            raise ValueError(\"Message validation failed\")\n        \n        # Apply middleware\n        for middleware in self.middleware:\n            message = await middleware(message)\n        \n        # Route message\n        try:\n            delivered_to = await self.message_router.route_message(message)\n            \n            # Handle acknowledgments\n            if requires_ack:\n                self.message_acknowledgments[message.header.message_id] = {\n                    \"message\": message,\n                    \"delivered_to\": delivered_to,\n                    \"pending_acks\": set(delivered_to),\n                    \"sent_at\": datetime.utcnow()\n                }\n            \n            # Update metrics\n            self.metrics[\"messages_sent\"] += 1\n            if sender_id in self.active_connections:\n                self.active_connections[sender_id][\"message_count\"] += 1\n            \n            logger.debug(\n                \"Message sent successfully\",\n                message_id=message.header.message_id,\n                message_type=message_type.value,\n                sender_id=sender_id,\n                recipients=len(delivered_to)\n            )\n            \n            return message.header.message_id\n            \n        except Exception as e:\n            # Add to retry queue if appropriate\n            if message.header.retry_count < message.header.max_retries:\n                self.retry_queues[priority].append(message)\n            else:\n                self.metrics[\"messages_dropped\"] += 1\n            \n            logger.error(\n                \"Failed to send message\",\n                message_type=message_type.value,\n                sender_id=sender_id,\n                error=str(e)\n            )\n            raise\n    \n    async def receive_messages(self, agent_id: str, max_messages: int = 10) -> List[Message]:\n        \"\"\"Receive pending messages for an agent.\"\"\"\n        if agent_id not in self.active_connections:\n            return []\n        \n        messages = self.message_router.get_pending_messages(agent_id, max_messages)\n        \n        # Update heartbeat\n        self.active_connections[agent_id][\"last_heartbeat\"] = datetime.utcnow()\n        \n        # Process messages through handlers\n        processed_messages = []\n        for message in messages:\n            try:\n                # Run message handlers\n                handlers = self.message_handlers.get(message.header.message_type, [])\n                for handler in handlers:\n                    await handler(message)\n                \n                processed_messages.append(message)\n                \n                # Send acknowledgment if required\n                if message.header.requires_ack:\n                    await self._send_acknowledgment(message, agent_id)\n                \n            except Exception as e:\n                logger.error(\n                    \"Error processing received message\",\n                    message_id=message.header.message_id,\n                    agent_id=agent_id,\n                    error=str(e)\n                )\n        \n        self.metrics[\"messages_received\"] += len(processed_messages)\n        return processed_messages\n    \n    async def _validate_message(self, message: Message) -> bool:\n        \"\"\"Validate message security and integrity.\"\"\"\n        # Check if sender is trusted\n        if message.header.sender_id not in self.trusted_agents:\n            logger.warning(f\"Message from untrusted sender: {message.header.sender_id}\")\n            return False\n        \n        # Verify message integrity\n        if not message.verify_integrity():\n            logger.warning(f\"Message integrity check failed: {message.header.message_id}\")\n            return False\n        \n        # Check message age\n        if message.is_expired():\n            logger.warning(f\"Expired message: {message.header.message_id}\")\n            return False\n        \n        # Run custom validators\n        for validator in self.message_validators:\n            if not await validator(message):\n                return False\n        \n        return True\n    \n    async def _send_acknowledgment(self, original_message: Message, agent_id: str) -> None:\n        \"\"\"Send acknowledgment for a received message.\"\"\"\n        ack_payload = {\n            \"original_message_id\": original_message.header.message_id,\n            \"acknowledged_by\": agent_id,\n            \"acknowledged_at\": datetime.utcnow().isoformat()\n        }\n        \n        await self.send_message(\n            message_type=MessageType.STATUS_UPDATE,\n            sender_id=agent_id,\n            recipient_id=original_message.header.sender_id,\n            payload=ack_payload,\n            correlation_id=original_message.header.message_id\n        )\n    \n    def register_message_handler(self, message_type: MessageType, handler: Callable) -> None:\n        \"\"\"Register a handler for specific message types.\"\"\"\n        self.message_handlers[message_type].append(handler)\n        logger.debug(f\"Handler registered for message type: {message_type.value}\")\n    \n    def add_middleware(self, middleware: Callable) -> None:\n        \"\"\"Add message processing middleware.\"\"\"\n        self.middleware.append(middleware)\n        logger.debug(\"Middleware added to communication system\")\n    \n    async def _register_default_handlers(self) -> None:\n        \"\"\"Register default message handlers.\"\"\"\n        \n        async def heartbeat_handler(message: Message) -> None:\n            \"\"\"Handle heartbeat messages.\"\"\"\n            sender_id = message.header.sender_id\n            if sender_id in self.active_connections:\n                self.active_connections[sender_id][\"last_heartbeat\"] = datetime.utcnow()\n        \n        async def error_handler(message: Message) -> None:\n            \"\"\"Handle error reports.\"\"\"\n            logger.warning(\n                \"Error reported by agent\",\n                agent_id=message.header.sender_id,\n                error_data=message.payload\n            )\n            \n            # Publish to error stream\n            await self.event_stream.publish_event(\"error_events\", {\n                \"agent_id\": message.header.sender_id,\n                \"error_data\": message.payload,\n                \"timestamp\": datetime.utcnow().isoformat()\n            })\n        \n        # Register handlers\n        self.register_message_handler(MessageType.HEARTBEAT, heartbeat_handler)\n        self.register_message_handler(MessageType.ERROR_REPORT, error_handler)\n    \n    async def _heartbeat_loop(self) -> None:\n        \"\"\"Send heartbeat messages and check agent health.\"\"\"\n        while not self.shutdown_event.is_set():\n            try:\n                current_time = datetime.utcnow()\n                stale_agents = []\n                \n                for agent_id, connection_info in self.active_connections.items():\n                    last_heartbeat = connection_info[\"last_heartbeat\"]\n                    time_since_heartbeat = (current_time - last_heartbeat).total_seconds()\n                    \n                    if time_since_heartbeat > 120:  # 2 minutes\n                        stale_agents.append(agent_id)\n                \n                # Remove stale agents\n                for agent_id in stale_agents:\n                    logger.warning(f\"Removing stale agent: {agent_id}\")\n                    await self.unregister_agent(agent_id)\n                \n                await asyncio.sleep(30)  # Check every 30 seconds\n                \n            except Exception as e:\n                logger.error(f\"Error in heartbeat loop: {str(e)}\", exc_info=True)\n                await asyncio.sleep(30)\n    \n    async def _retry_loop(self) -> None:\n        \"\"\"Process message retry queues.\"\"\"\n        while not self.shutdown_event.is_set():\n            try:\n                # Process retry queues in priority order\n                for priority in [MessagePriority.CRITICAL, MessagePriority.HIGH, \n                               MessagePriority.NORMAL, MessagePriority.LOW]:\n                    queue = self.retry_queues[priority]\n                    \n                    if queue:\n                        message = queue.popleft()\n                        message.header.retry_count += 1\n                        \n                        try:\n                            await self.message_router.route_message(message)\n                        except Exception as e:\n                            if message.header.retry_count < message.header.max_retries:\n                                # Exponential backoff\n                                await asyncio.sleep(2 ** message.header.retry_count)\n                                queue.append(message)\n                            else:\n                                self.metrics[\"messages_dropped\"] += 1\n                                logger.error(f\"Message permanently failed: {message.header.message_id}\")\n                \n                await asyncio.sleep(5)  # Process retries every 5 seconds\n                \n            except Exception as e:\n                logger.error(f\"Error in retry loop: {str(e)}\", exc_info=True)\n                await asyncio.sleep(30)\n    \n    async def _metrics_loop(self) -> None:\n        \"\"\"Calculate and update system metrics.\"\"\"\n        last_message_count = 0\n        \n        while not self.shutdown_event.is_set():\n            try:\n                current_time = time.time()\n                current_messages = self.metrics[\"messages_sent\"]\n                \n                # Calculate throughput\n                messages_this_period = current_messages - last_message_count\n                self.metrics[\"throughput_per_second\"] = messages_this_period / 60  # Per minute average\n                \n                # Update active agent count\n                self.metrics[\"active_agents\"] = len(self.active_connections)\n                \n                last_message_count = current_messages\n                \n                await asyncio.sleep(60)  # Update metrics every minute\n                \n            except Exception as e:\n                logger.error(f\"Error in metrics loop: {str(e)}\", exc_info=True)\n                await asyncio.sleep(60)\n    \n    async def _cleanup_loop(self) -> None:\n        \"\"\"Clean up old acknowledgments and expired data.\"\"\"\n        while not self.shutdown_event.is_set():\n            try:\n                current_time = datetime.utcnow()\n                \n                # Clean up old acknowledgments (older than 1 hour)\n                expired_acks = [\n                    msg_id for msg_id, ack_info in self.message_acknowledgments.items()\n                    if (current_time - ack_info[\"sent_at\"]).total_seconds() > 3600\n                ]\n                \n                for msg_id in expired_acks:\n                    del self.message_acknowledgments[msg_id]\n                \n                await asyncio.sleep(300)  # Clean up every 5 minutes\n                \n            except Exception as e:\n                logger.error(f\"Error in cleanup loop: {str(e)}\", exc_info=True)\n                await asyncio.sleep(300)\n    \n    async def get_system_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive communication system status.\"\"\"\n        return {\n            \"status\": \"running\" if self.is_running else \"stopped\",\n            \"active_agents\": len(self.active_connections),\n            \"agent_types\": {\n                agent_type.value: len(agents) \n                for agent_type, agents in self.connection_pools.items()\n            },\n            \"metrics\": self.metrics,\n            \"routing_metrics\": self.message_router.routing_metrics,\n            \"pending_acknowledgments\": len(self.message_acknowledgments),\n            \"retry_queue_sizes\": {\n                priority.value: len(queue) \n                for priority, queue in self.retry_queues.items()\n            },\n            \"event_streams\": list(self.event_stream.streams.keys()),\n            \"trusted_agents\": len(self.trusted_agents)\n        }\n    \n    async def shutdown(self) -> None:\n        \"\"\"Gracefully shutdown the communication system.\"\"\"\n        logger.info(\"Shutting down agent communication system\")\n        \n        self.shutdown_event.set()\n        \n        # Cancel background tasks\n        for task in [self.heartbeat_task, self.retry_task, self.metrics_task, self.cleanup_task]:\n            if task:\n                task.cancel()\n        \n        # Notify all agents about shutdown\n        shutdown_payload = {\"reason\": \"system_shutdown\", \"timestamp\": datetime.utcnow().isoformat()}\n        \n        for agent_id in list(self.active_connections.keys()):\n            try:\n                await self.send_message(\n                    MessageType.SHUTDOWN,\n                    \"system\",\n                    shutdown_payload,\n                    recipient_id=agent_id,\n                    priority=MessagePriority.CRITICAL\n                )\n            except Exception as e:\n                logger.warning(f\"Failed to notify agent {agent_id} of shutdown: {str(e)}\")\n        \n        self.is_running = False\n        logger.info(\"Agent communication system shutdown complete\")\n\n\n# Global communication system instance\ncommunication_system = AgentCommunicationSystem()\n\n\nasync def get_communication_system() -> AgentCommunicationSystem:\n    \"\"\"Get the global communication system instance.\"\"\"\n    if not communication_system.is_running:\n        await communication_system.initialize()\n    return communication_system