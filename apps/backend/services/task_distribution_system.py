"""
Task Distribution and Execution System for Multi-Agent Orchestration.

Implements intelligent task routing, load balancing, and execution monitoring
for the 100+ agent ecosystem with advanced scheduling and resource management.
"""

import asyncio
import heapq
import time
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Set, Tuple, Union
from enum import Enum
from dataclasses import dataclass, field
from collections import defaultdict, deque
import uuid
import structlog

from pydantic import BaseModel, Field
from core.config import get_settings
from services.agent_orchestrator import AgentType, TaskPriority, TaskStatus

logger = structlog.get_logger(__name__)
settings = get_settings()


class SchedulingStrategy(str, Enum):
    """Task scheduling strategies."""
    FIFO = "fifo"                    # First In, First Out
    PRIORITY = "priority"            # Priority-based scheduling
    SHORTEST_JOB = "shortest_job"    # Shortest job first
    ROUND_ROBIN = "round_robin"      # Round robin across agents
    LOAD_BALANCED = "load_balanced"  # Dynamic load balancing
    DEADLINE_AWARE = "deadline_aware"# Earliest deadline first
    RESOURCE_AWARE = "resource_aware"# Resource-optimized scheduling


class LoadBalancingStrategy(str, Enum):
    """Load balancing strategies for agent distribution."""
    LEAST_LOADED = "least_loaded"        # Agent with lowest current load
    ROUND_ROBIN = "round_robin"          # Rotate through available agents
    PERFORMANCE_BASED = "performance_based"  # Based on historical performance
    CAPABILITY_MATCHED = "capability_matched"  # Match task to best capability
    COST_OPTIMIZED = "cost_optimized"    # Minimize resource costs
    LATENCY_OPTIMIZED = "latency_optimized"  # Minimize response time


class ResourceType(str, Enum):
    """Types of resources that can be allocated."""
    CPU = "cpu"
    MEMORY = "memory"
    TOKEN_BUDGET = "token_budget"
    NETWORK_BANDWIDTH = "network_bandwidth"
    STORAGE_IOPS = "storage_iops"
    GPU_MEMORY = "gpu_memory"
    CONCURRENT_CONNECTIONS = "concurrent_connections"


@dataclass
class ResourceAllocation:
    """Resource allocation for a task or agent."""
    cpu_cores: float = 0.5
    memory_mb: int = 512
    token_budget: int = 4000
    network_bandwidth_mbps: float = 10.0
    storage_iops: int = 100
    gpu_memory_mb: int = 0
    concurrent_limit: int = 1
    timeout_seconds: int = 300


@dataclass
class TaskExecution:
    """Represents a task execution with metadata."""
    task_id: str
    agent_type: AgentType
    operation: str
    parameters: Dict[str, Any] = field(default_factory=dict)
    context: Dict[str, Any] = field(default_factory=dict)
    priority: TaskPriority = TaskPriority.MEDIUM
    dependencies: List[str] = field(default_factory=list)
    estimated_duration: timedelta = field(default=timedelta(minutes=5))
    deadline: Optional[datetime] = None
    resource_requirements: ResourceAllocation = field(default_factory=ResourceAllocation)
    retry_count: int = 0
    max_retries: int = 3
    created_at: datetime = field(default_factory=datetime.utcnow)
    scheduled_at: Optional[datetime] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    status: TaskStatus = TaskStatus.PENDING
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    execution_trace: List[str] = field(default_factory=list)
    metrics: Dict[str, Any] = field(default_factory=dict)


@dataclass
class AgentResource:
    """Tracks agent resource usage and availability."""
    agent_type: AgentType
    total_resources: ResourceAllocation
    used_resources: ResourceAllocation = field(default_factory=ResourceAllocation)
    active_tasks: Set[str] = field(default_factory=set)
    task_history: deque = field(default_factory=lambda: deque(maxlen=100))
    performance_metrics: Dict[str, float] = field(default_factory=dict)
    last_activity: datetime = field(default_factory=datetime.utcnow)
    health_status: str = "healthy"


class TaskDistributionSystem:
    """
    Advanced task distribution and execution system for multi-agent orchestration.
    
    Features:
    - Intelligent task scheduling with multiple strategies
    - Dynamic load balancing across agent types
    - Resource-aware allocation and monitoring
    - Deadline-aware scheduling
    - Performance-based optimization
    - Comprehensive execution tracking
    """
    
    def __init__(self):
        # Task queues and scheduling
        self.task_queue: List[Tuple[float, str, TaskExecution]] = []  # Priority queue
        self.scheduled_tasks: Dict[str, TaskExecution] = {}
        self.executing_tasks: Dict[str, TaskExecution] = {}
        self.completed_tasks: Dict[str, TaskExecution] = {}
        self.failed_tasks: Dict[str, TaskExecution] = {}
        
        # Agent resource management
        self.agent_resources: Dict[AgentType, AgentResource] = {}
        self.agent_queues: Dict[AgentType, deque] = defaultdict(deque)
        self.agent_round_robin: Dict[AgentType, int] = defaultdict(int)
        
        # Scheduling configuration
        self.scheduling_strategy = SchedulingStrategy.PRIORITY
        self.load_balancing_strategy = LoadBalancingStrategy.LEAST_LOADED
        self.max_concurrent_tasks = 50
        self.task_timeout_default = 300  # seconds
        
        # Performance metrics
        self.metrics = {\n            "tasks_submitted": 0,\n            "tasks_completed": 0,\n            "tasks_failed": 0,\n            "average_execution_time": 0,\n            "average_queue_time": 0,\n            "resource_utilization": {},\n            "agent_performance": {},\n            "throughput_per_minute": 0\n        }\n        \n        # Background tasks\n        self.scheduler_task: Optional[asyncio.Task] = None\n        self.monitor_task: Optional[asyncio.Task] = None\n        self.metrics_task: Optional[asyncio.Task] = None\n        \n        self.is_running = False\n        self.shutdown_event = asyncio.Event()\n    \n    async def initialize(self) -> None:\n        \"\"\"Initialize the task distribution system.\"\"\"\n        try:\n            # Initialize agent resources for all known agent types\n            await self._initialize_agent_resources()\n            \n            # Start background tasks\n            self.scheduler_task = asyncio.create_task(self._scheduler_loop())\n            self.monitor_task = asyncio.create_task(self._monitor_loop())\n            self.metrics_task = asyncio.create_task(self._metrics_loop())\n            \n            self.is_running = True\n            logger.info("Task distribution system initialized")\n            \n        except Exception as e:\n            logger.error(f"Failed to initialize task distribution system: {str(e)}")\n            raise\n    \n    async def _initialize_agent_resources(self) -> None:\n        \"\"\"Initialize resource tracking for all agent types.\"\"\"\n        # Define default resource allocations for different agent types\n        resource_profiles = {\n            # High-resource agents\n            AgentType.AI_ENGINEER: ResourceAllocation(\n                cpu_cores=2.0, memory_mb=2048, token_budget=8000,\n                concurrent_limit=2, timeout_seconds=600\n            ),\n            AgentType.CONTEXT_MANAGER: ResourceAllocation(\n                cpu_cores=1.5, memory_mb=1536, token_budget=6000,\n                concurrent_limit=3, timeout_seconds=300\n            ),\n            AgentType.PROJECT_ARCHITECT: ResourceAllocation(\n                cpu_cores=1.5, memory_mb=1024, token_budget=6000,\n                concurrent_limit=2, timeout_seconds=450\n            ),\n            \n            # Medium-resource agents\n            AgentType.FULLSTACK_DEVELOPER: ResourceAllocation(\n                cpu_cores=1.0, memory_mb=1024, token_budget=4000,\n                concurrent_limit=3, timeout_seconds=360\n            ),\n            AgentType.BACKEND_DEVELOPER: ResourceAllocation(\n                cpu_cores=1.0, memory_mb=768, token_budget=3000,\n                concurrent_limit=4, timeout_seconds=300\n            ),\n            AgentType.FRONTEND_DEVELOPER: ResourceAllocation(\n                cpu_cores=1.0, memory_mb=768, token_budget=3000,\n                concurrent_limit=4, timeout_seconds=300\n            ),\n            \n            # Low-resource agents\n            AgentType.EDITOR: ResourceAllocation(\n                cpu_cores=0.5, memory_mb=256, token_budget=2000,\n                concurrent_limit=5, timeout_seconds=180\n            ),\n            AgentType.CODE_REVIEWER: ResourceAllocation(\n                cpu_cores=0.5, memory_mb=512, token_budget=2500,\n                concurrent_limit=4, timeout_seconds=240\n            ),\n        }\n        \n        # Initialize resources for all agent types\n        for agent_type in AgentType:\n            if agent_type in resource_profiles:\n                resources = resource_profiles[agent_type]\n            else:\n                # Default resource allocation\n                resources = ResourceAllocation()\n            \n            self.agent_resources[agent_type] = AgentResource(\n                agent_type=agent_type,\n                total_resources=resources\n            )\n        \n        logger.info(f"Initialized resources for {len(self.agent_resources)} agent types")\n    \n    async def submit_task(\n        self,\n        agent_type: AgentType,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        context: Optional[Dict[str, Any]] = None,\n        priority: TaskPriority = TaskPriority.MEDIUM,\n        dependencies: Optional[List[str]] = None,\n        deadline: Optional[datetime] = None,\n        resource_requirements: Optional[ResourceAllocation] = None\n    ) -> str:\n        \"\"\"Submit a task for execution.\"\"\"\n        task_id = str(uuid.uuid4())\n        \n        task = TaskExecution(\n            task_id=task_id,\n            agent_type=agent_type,\n            operation=operation,\n            parameters=parameters or {},\n            context=context or {},\n            priority=priority,\n            dependencies=dependencies or [],\n            deadline=deadline,\n            resource_requirements=resource_requirements or ResourceAllocation()\n        )\n        \n        # Add to task queue with priority\n        priority_score = self._calculate_priority_score(task)\n        heapq.heappush(self.task_queue, (priority_score, task_id, task))\n        self.scheduled_tasks[task_id] = task\n        \n        # Update metrics\n        self.metrics[\"tasks_submitted\"] += 1\n        \n        logger.info(\n            \"Task submitted\",\n            task_id=task_id,\n            agent_type=agent_type.value,\n            operation=operation,\n            priority=priority.value\n        )\n        \n        return task_id\n    \n    def _calculate_priority_score(self, task: TaskExecution) -> float:\n        \"\"\"Calculate priority score for task scheduling.\"\"\"\n        # Lower score = higher priority\n        base_priority = {\n            TaskPriority.CRITICAL: 0,\n            TaskPriority.HIGH: 100,\n            TaskPriority.MEDIUM: 200,\n            TaskPriority.LOW: 300\n        }[task.priority]\n        \n        # Adjust for deadline urgency\n        deadline_factor = 0\n        if task.deadline:\n            time_to_deadline = (task.deadline - datetime.utcnow()).total_seconds()\n            if time_to_deadline > 0:\n                # More urgent tasks get lower scores\n                deadline_factor = max(0, 100 - (time_to_deadline / 60))  # Minutes to deadline\n        \n        # Adjust for task age (prevent starvation)\n        age_factor = (datetime.utcnow() - task.created_at).total_seconds() / 60  # Minutes\n        age_bonus = min(50, age_factor)  # Cap age bonus at 50\n        \n        return base_priority + deadline_factor - age_bonus\n    \n    async def _scheduler_loop(self) -> None:\n        \"\"\"Main scheduler loop that processes the task queue.\"\"\"\n        while not self.shutdown_event.is_set():\n            try:\n                await self._schedule_tasks()\n                await asyncio.sleep(0.1)  # Short delay to prevent busy waiting\n                \n            except Exception as e:\n                logger.error(f\"Error in scheduler loop: {str(e)}\", exc_info=True)\n                await asyncio.sleep(1)  # Longer delay on error\n    \n    async def _schedule_tasks(self) -> None:\n        \"\"\"Schedule tasks from the queue for execution.\"\"\"\n        # Check if we're at capacity\n        if len(self.executing_tasks) >= self.max_concurrent_tasks:\n            return\n        \n        # Process tasks from the priority queue\n        tasks_to_schedule = []\n        \n        while self.task_queue and len(tasks_to_schedule) < 10:  # Batch processing\n            try:\n                _, task_id, task = heapq.heappop(self.task_queue)\n                \n                # Check if dependencies are satisfied\n                if await self._check_dependencies_satisfied(task):\n                    # Check resource availability\n                    if await self._check_resource_availability(task):\n                        tasks_to_schedule.append(task)\n                    else:\n                        # Put back in queue with slightly higher priority\n                        priority_score = self._calculate_priority_score(task) - 1\n                        heapq.heappush(self.task_queue, (priority_score, task_id, task))\n                else:\n                    # Dependencies not satisfied, put back in queue\n                    priority_score = self._calculate_priority_score(task)\n                    heapq.heappush(self.task_queue, (priority_score, task_id, task))\n                    \n            except IndexError:\n                break  # Queue is empty\n        \n        # Execute scheduled tasks\n        for task in tasks_to_schedule:\n            await self._execute_task(task)\n    \n    async def _check_dependencies_satisfied(self, task: TaskExecution) -> bool:\n        \"\"\"Check if all task dependencies are satisfied.\"\"\"\n        for dep_id in task.dependencies:\n            if dep_id not in self.completed_tasks:\n                return False\n        return True\n    \n    async def _check_resource_availability(self, task: TaskExecution) -> bool:\n        \"\"\"Check if required resources are available for the task.\"\"\"\n        agent_resource = self.agent_resources.get(task.agent_type)\n        if not agent_resource:\n            return False\n        \n        # Check concurrent task limit\n        if len(agent_resource.active_tasks) >= agent_resource.total_resources.concurrent_limit:\n            return False\n        \n        # Check specific resource requirements\n        available_cpu = (agent_resource.total_resources.cpu_cores - \n                        agent_resource.used_resources.cpu_cores)\n        available_memory = (agent_resource.total_resources.memory_mb - \n                           agent_resource.used_resources.memory_mb)\n        available_tokens = (agent_resource.total_resources.token_budget - \n                           agent_resource.used_resources.token_budget)\n        \n        return (available_cpu >= task.resource_requirements.cpu_cores and\n                available_memory >= task.resource_requirements.memory_mb and\n                available_tokens >= task.resource_requirements.token_budget)\n    \n    async def _execute_task(self, task: TaskExecution) -> None:\n        \"\"\"Execute a task asynchronously.\"\"\"\n        task.status = TaskStatus.IN_PROGRESS\n        task.started_at = datetime.utcnow()\n        task.scheduled_at = datetime.utcnow()\n        \n        # Move to executing tasks\n        self.executing_tasks[task.task_id] = task\n        if task.task_id in self.scheduled_tasks:\n            del self.scheduled_tasks[task.task_id]\n        \n        # Reserve resources\n        await self._reserve_resources(task)\n        \n        logger.info(\n            \"Task execution started\",\n            task_id=task.task_id,\n            agent_type=task.agent_type.value,\n            operation=task.operation\n        )\n        \n        # Create execution coroutine\n        execution_coro = self._run_task_execution(task)\n        \n        # Run task with timeout\n        try:\n            await asyncio.wait_for(\n                execution_coro,\n                timeout=task.resource_requirements.timeout_seconds\n            )\n        except asyncio.TimeoutError:\n            await self._handle_task_timeout(task)\n        except Exception as e:\n            await self._handle_task_error(task, e)\n    \n    async def _run_task_execution(self, task: TaskExecution) -> None:\n        \"\"\"Run the actual task execution logic.\"\"\"\n        try:\n            # This would integrate with the actual agent execution system\n            # For now, simulating task execution\n            \n            # Add execution trace\n            task.execution_trace.append(f\"Started execution at {datetime.utcnow()}\")\n            \n            # Simulate work based on estimated duration\n            work_duration = task.estimated_duration.total_seconds()\n            await asyncio.sleep(min(work_duration, 1.0))  # Cap simulation time\n            \n            # Simulate result\n            result = {\n                \"success\": True,\n                \"operation\": task.operation,\n                \"agent_type\": task.agent_type.value,\n                \"execution_time\": (datetime.utcnow() - task.started_at).total_seconds(),\n                \"simulated\": True  # Mark as simulation\n            }\n            \n            await self._complete_task(task, result)\n            \n        except Exception as e:\n            await self._handle_task_error(task, e)\n    \n    async def _complete_task(self, task: TaskExecution, result: Dict[str, Any]) -> None:\n        \"\"\"Complete a task successfully.\"\"\"\n        task.status = TaskStatus.COMPLETED\n        task.completed_at = datetime.utcnow()\n        task.result = result\n        \n        # Calculate execution metrics\n        execution_time = (task.completed_at - task.started_at).total_seconds()\n        queue_time = (task.started_at - task.created_at).total_seconds()\n        \n        task.metrics = {\n            \"execution_time_seconds\": execution_time,\n            \"queue_time_seconds\": queue_time,\n            \"total_time_seconds\": execution_time + queue_time\n        }\n        \n        # Move to completed tasks\n        self.completed_tasks[task.task_id] = task\n        if task.task_id in self.executing_tasks:\n            del self.executing_tasks[task.task_id]\n        \n        # Release resources\n        await self._release_resources(task)\n        \n        # Update metrics\n        self.metrics[\"tasks_completed\"] += 1\n        self._update_performance_metrics(task)\n        \n        logger.info(\n            \"Task completed successfully\",\n            task_id=task.task_id,\n            agent_type=task.agent_type.value,\n            execution_time=execution_time,\n            queue_time=queue_time\n        )\n    \n    async def _handle_task_error(self, task: TaskExecution, error: Exception) -> None:\n        \"\"\"Handle task execution errors.\"\"\"\n        task.error = str(error)\n        task.execution_trace.append(f\"Error occurred at {datetime.utcnow()}: {str(error)}\")\n        \n        # Check if we should retry\n        if task.retry_count < task.max_retries:\n            task.retry_count += 1\n            task.status = TaskStatus.PENDING\n            \n            # Add back to queue with delay\n            await asyncio.sleep(2 ** task.retry_count)  # Exponential backoff\n            \n            priority_score = self._calculate_priority_score(task)\n            heapq.heappush(self.task_queue, (priority_score, task.task_id, task))\n            self.scheduled_tasks[task.task_id] = task\n            \n            logger.warning(\n                \"Task failed, retrying\",\n                task_id=task.task_id,\n                retry_count=task.retry_count,\n                error=str(error)\n            )\n        else:\n            # Max retries reached, mark as failed\n            task.status = TaskStatus.FAILED\n            task.completed_at = datetime.utcnow()\n            \n            self.failed_tasks[task.task_id] = task\n            if task.task_id in self.executing_tasks:\n                del self.executing_tasks[task.task_id]\n            \n            self.metrics[\"tasks_failed\"] += 1\n            \n            logger.error(\n                \"Task failed permanently\",\n                task_id=task.task_id,\n                agent_type=task.agent_type.value,\n                error=str(error),\n                retry_count=task.retry_count\n            )\n        \n        # Always release resources on error\n        await self._release_resources(task)\n    \n    async def _handle_task_timeout(self, task: TaskExecution) -> None:\n        \"\"\"Handle task execution timeout.\"\"\"\n        timeout_error = f\"Task timed out after {task.resource_requirements.timeout_seconds} seconds\"\n        await self._handle_task_error(task, Exception(timeout_error))\n    \n    async def _reserve_resources(self, task: TaskExecution) -> None:\n        \"\"\"Reserve resources for task execution.\"\"\"\n        agent_resource = self.agent_resources[task.agent_type]\n        \n        # Add to active tasks\n        agent_resource.active_tasks.add(task.task_id)\n        \n        # Update resource usage\n        agent_resource.used_resources.cpu_cores += task.resource_requirements.cpu_cores\n        agent_resource.used_resources.memory_mb += task.resource_requirements.memory_mb\n        agent_resource.used_resources.token_budget += task.resource_requirements.token_budget\n        \n        agent_resource.last_activity = datetime.utcnow()\n    \n    async def _release_resources(self, task: TaskExecution) -> None:\n        \"\"\"Release resources after task completion.\"\"\"\n        agent_resource = self.agent_resources[task.agent_type]\n        \n        # Remove from active tasks\n        agent_resource.active_tasks.discard(task.task_id)\n        \n        # Update resource usage\n        agent_resource.used_resources.cpu_cores = max(\n            0, agent_resource.used_resources.cpu_cores - task.resource_requirements.cpu_cores\n        )\n        agent_resource.used_resources.memory_mb = max(\n            0, agent_resource.used_resources.memory_mb - task.resource_requirements.memory_mb\n        )\n        agent_resource.used_resources.token_budget = max(\n            0, agent_resource.used_resources.token_budget - task.resource_requirements.token_budget\n        )\n        \n        # Add to task history\n        agent_resource.task_history.append({\n            \"task_id\": task.task_id,\n            \"operation\": task.operation,\n            \"status\": task.status.value,\n            \"execution_time\": task.metrics.get(\"execution_time_seconds\", 0),\n            \"completed_at\": datetime.utcnow()\n        })\n        \n        agent_resource.last_activity = datetime.utcnow()\n    \n    def _update_performance_metrics(self, task: TaskExecution) -> None:\n        \"\"\"Update system performance metrics.\"\"\"\n        # Update average execution time\n        current_avg = self.metrics[\"average_execution_time\"]\n        completed_count = self.metrics[\"tasks_completed\"]\n        execution_time = task.metrics[\"execution_time_seconds\"]\n        \n        new_avg = ((current_avg * (completed_count - 1)) + execution_time) / completed_count\n        self.metrics[\"average_execution_time\"] = new_avg\n        \n        # Update average queue time\n        queue_avg = self.metrics[\"average_queue_time\"]\n        queue_time = task.metrics[\"queue_time_seconds\"]\n        \n        new_queue_avg = ((queue_avg * (completed_count - 1)) + queue_time) / completed_count\n        self.metrics[\"average_queue_time\"] = new_queue_avg\n        \n        # Update agent-specific performance metrics\n        agent_type = task.agent_type\n        if agent_type.value not in self.metrics[\"agent_performance\"]:\n            self.metrics[\"agent_performance\"][agent_type.value] = {\n                \"completed_tasks\": 0,\n                \"average_execution_time\": 0,\n                \"success_rate\": 0\n            }\n        \n        agent_metrics = self.metrics[\"agent_performance\"][agent_type.value]\n        agent_completed = agent_metrics[\"completed_tasks\"] + 1\n        \n        # Update agent average execution time\n        agent_avg = agent_metrics[\"average_execution_time\"]\n        new_agent_avg = ((agent_avg * (agent_completed - 1)) + execution_time) / agent_completed\n        \n        agent_metrics[\"completed_tasks\"] = agent_completed\n        agent_metrics[\"average_execution_time\"] = new_agent_avg\n    \n    async def _monitor_loop(self) -> None:\n        \"\"\"Monitor system health and resource usage.\"\"\"\n        while not self.shutdown_event.is_set():\n            try:\n                await self._update_resource_utilization()\n                await self._check_agent_health()\n                await self._cleanup_old_tasks()\n                await asyncio.sleep(30)  # Monitor every 30 seconds\n                \n            except Exception as e:\n                logger.error(f\"Error in monitor loop: {str(e)}\", exc_info=True)\n                await asyncio.sleep(30)\n    \n    async def _update_resource_utilization(self) -> None:\n        \"\"\"Update resource utilization metrics.\"\"\"\n        utilization = {}\n        \n        for agent_type, resource in self.agent_resources.items():\n            total_cpu = resource.total_resources.cpu_cores\n            used_cpu = resource.used_resources.cpu_cores\n            total_memory = resource.total_resources.memory_mb\n            used_memory = resource.used_resources.memory_mb\n            total_tokens = resource.total_resources.token_budget\n            used_tokens = resource.used_resources.token_budget\n            \n            utilization[agent_type.value] = {\n                \"cpu_utilization\": (used_cpu / total_cpu) if total_cpu > 0 else 0,\n                \"memory_utilization\": (used_memory / total_memory) if total_memory > 0 else 0,\n                \"token_utilization\": (used_tokens / total_tokens) if total_tokens > 0 else 0,\n                \"active_tasks\": len(resource.active_tasks),\n                \"concurrent_limit\": resource.total_resources.concurrent_limit\n            }\n        \n        self.metrics[\"resource_utilization\"] = utilization\n    \n    async def get_system_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system status.\"\"\"\n        return {\n            \"status\": \"running\" if self.is_running else \"stopped\",\n            \"task_queue_size\": len(self.task_queue),\n            \"executing_tasks\": len(self.executing_tasks),\n            \"completed_tasks\": len(self.completed_tasks),\n            \"failed_tasks\": len(self.failed_tasks),\n            \"agent_count\": len(self.agent_resources),\n            \"metrics\": self.metrics,\n            \"scheduling_strategy\": self.scheduling_strategy.value,\n            \"load_balancing_strategy\": self.load_balancing_strategy.value,\n            \"max_concurrent_tasks\": self.max_concurrent_tasks,\n            \"resource_utilization\": self.metrics.get(\"resource_utilization\", {})\n        }\n    \n    async def shutdown(self) -> None:\n        \"\"\"Gracefully shutdown the task distribution system.\"\"\"\n        logger.info(\"Shutting down task distribution system\")\n        \n        self.shutdown_event.set()\n        \n        # Cancel background tasks\n        if self.scheduler_task:\n            self.scheduler_task.cancel()\n        if self.monitor_task:\n            self.monitor_task.cancel()\n        if self.metrics_task:\n            self.metrics_task.cancel()\n        \n        # Wait for executing tasks to complete (with timeout)\n        timeout = 30\n        start_time = time.time()\n        \n        while self.executing_tasks and (time.time() - start_time) < timeout:\n            await asyncio.sleep(1)\n        \n        self.is_running = False\n        logger.info(\"Task distribution system shutdown complete\")\n\n\n# Global task distribution system instance\ntask_distribution_system = TaskDistributionSystem()\n\n\nasync def get_task_distribution_system() -> TaskDistributionSystem:\n    \"\"\"Get the global task distribution system instance.\"\"\"\n    if not task_distribution_system.is_running:\n        await task_distribution_system.initialize()\n    return task_distribution_system